
\section{Introduction}
\label{sec:introduction}

The AGWS requires the use of 4 guide stars (GS).
AGWS Target Practice (ATP) is an application program interface allowing to model
the sky as viewed by the AGWS.
It also implements the routines to find the most suitable GSs for the AGWS in the different
modes of operation of the telescope.

\section{Installation}
\label{sec:installation}

\section{Implementation}
\label{sec:implementation}

The main python module is
<<atp.py>>=
<<module imports>>
import ceo
from datetime import datetime
RAD2MAS = 180*3600e3/np.pi
RAD2ARCSEC = 180*3600/np.pi
ARCMIN2RAD = np.pi/180/60
<<TT7 performance estimator>>
<<SH GSs>>
<<observatory>>
<<target>>
<<star field>>
<<probe>>

if __name__ == "__main__":
    CFG_FILE = 'atp.yaml'
    <<atp main>>
@ with
<<atp main>>=
<<reading the atp config file>>
obs = Observatory(cfg['Observatory'],cfg['Observation'])
target = Target(obs,cfg['Observatory'])
stars  = StarField(obs,target)
tt_res_rms = [tt7_res_rms(zz,magnitude) \
              for zz,magnitude in zip(stars.distanceFrom(u='arcmin').value,stars.V)]
tt7_gs_idx = np.argmin(tt_res_rms)
probes  = []
tt7_dist = []
for k in range(4):
    probes += [Probe(Quantity(k*90,'degree'))]
    probes[k].reachForTheStars(stars)
    tt7_dist += [stars.distanceFrom(Quantity(probes[k].local,'rad'),
                                    star_idx=[tt7_gs_idx],u='arcmin')]
tt7_idx = np.argmin(tt7_dist)
TT7 = probes[tt7_idx]
TT7.gs_idx = tt7_gs_idx
probes.pop(tt7_idx)
#SH_GSs()
@
\subsection{Configuration}
\label{sec:config}

<<atp.yaml>>=
<<Observation config>>
<<Observatory config>>
<<Star field config>>
@
The configuration file is read with:
<<module imports>>=
import yaml
@
<<reading the atp config file>>=
with open(CFG_FILE) as fp:
    cfg = yaml.load(fp)
@ %def cfg


\section{Observation}
\label{sec:observation}

The observation date and UTC time must be given.
The time resolution of the observation is used as the sampling time of the simulation.

<<Observation config>>=
Observation:
   time: '2018-01-01T00:00:00'
   time resolution: [60,'second']
@ 
\section{The Observatory}
\label{sec:gmt}

The observatory coordinates are:

<<Observatory config>>=
Observatory:
   latitude: [-29.049,'degree']
   longitude:  [-70.682,'degree']
   height: [2514,'meter']
   pointing target: null
   pointing ra/dec: null
   pointing alt/az:
      alt: [45,'degree']
      az: [0,'degree']
   pointing accuracy: null
@
The [[Observatory]] class contains the geodetic coordinates of the telescope and the
observation date, time and time resolution.
<<observatory>>=
class Observatory:
    def __init__(self,observatory_args,observation_args):
        self.location = EarthLocation(lat=Quantity(*observatory_args['latitude']),
                                      lon=Quantity(*observatory_args['longitude']),
                                      height=Quantity(*observatory_args['height']))
        self.start_time = Time(observation_args['time'])
        self.current_time  = Time(observation_args['time'])
        if self.current_time is None:
            self.current_time = Time(datetime.now())
        self.time_resolution = Quantity(*observation_args['time resolution'])
        print(str(self))

    def __str__(self):
        return "@(Observatory)> Location: "+str(self.location.geodetic)+\
               "\n@(Observatory)> Time: "+str(self.current_time)

    <<observatory method>>
@ %def Observatory 
The [[update]] method accrues the observation time by the time resolution amount:
<<observatory method>>=
def update(self):
    self.current_time += self.time_resolution
@
The telescope alt/az frame of reference is associated to the [[frame]] property.
<<observatory method>>=
@property
def frame(self):
    return AltAz(obstime=self.current_time,
                 location=self.location)
@
The sidereal time is obtained from the [[sidereal_time]] property:
<<observatory method>>=
@property
def sidereal_time(self):
    return self.current_time.sidereal_time('apparent',self.location.lon)
@

\section{Target}
\label{sec:target}

The target defines the direction the telescope is pointing at.
The target is defined by either the name of an astronomical object or sky coordinates in ra/dec or alt/az.
<<target>>=
class Target:
    def __init__(self,obs,pointing_args=None,icrs=None):
        self.obs = obs
        if pointing_args is not None:
            if pointing_args['pointing target'] not in [None,'None']:
                self.icrs  = SkyCoord.from_name(pointing_args['pointing target'],
                                                frame='icrs')
            elif pointing_args['pointing ra/dec'] is not None:
                self.icrs  = SkyCoord(ra=Quantity(*pointing_args['pointing ra/dec']['ra']),
                                      dec=Quantity(*pointing_args['pointing ra/dec']['dec']),
                                      frame='icrs')
            elif pointing_args['pointing alt/az'] is not None:
                self.altaz = SkyCoord(alt=Quantity(*pointing_args['pointing alt/az']['alt']),
                                      az=Quantity(*pointing_args['pointing alt/az']['az']),
                                      frame = obs.frame)
                self.icrs  = self.altaz.transform_to( ICRS() )
        if icrs is not None:
            self.icrs = icrs
        self.rotator_angle = Quantity(0,'degree')
        self.update(rotator=False)
        print("@(Target)>")
        print(self.icrs)
        print(self.altaz)

    <<target method>>
@ %def Target
The [[update]] method updates the alt/az coordinates of the target along with
the parallactic angle and the rotator angle according to observatory current
time.
<<target method>>=
def update(self,rotator=True):
    self.altaz = self.icrs.transform_to( self.obs.frame )
    H = (self.obs.sidereal_time.to(units.rad) - self.icrs.ra.to(units.rad)).value
    D = self.icrs.dec.to(units.rad).value
    L = self.obs.location.lat.to(units.rad).value
    self.parallactic_angle = Quantity(np.arctan2( np.sin(L)*np.cos(D) - \
                                                  np.cos(L)*np.cos(H)*np.sin(D) ,
                                                  -np.cos(L)*np.sin(H) ) , 'deg')
    if rotator:
        self.rotator_angle += np.cos(self.obs.location.lat)*np.cos(self.altaz.az)/\
                              np.cos(self.altaz.alt)*\
                              self.obs.time_resolution.to('s').value*\
                              Quantity(15,'degree')/3600
@

\section{AGWS Star Field}
\label{sec:star-field}

<<Star field config>>=
STAR CATALOG:
  ra/dec error rms: null
  exclude radius: [3,'arcmin']
  R magnitude limit: 18
@
An AGWS star field is read from the TESS Input Catalogue (TIC\footnote{\url{https://tess.mit.edu/data/tess-input-catalogue/}}).
A 10 arcmin radius circular region is queried from the catalogue centered on either a given target or a given sky alt/az coordinate.
An observation date and time must also be specified.
The data is further reduced to objects that have both a magnitude in V and J bands.
<<module imports>>=
import numpy as np
from astroquery.mast import Catalogs
import astropy.units as units
from astropy.units import Quantity
from astropy.time import Time
from astropy.coordinates import SkyCoord, EarthLocation, ICRS, AltAz
@ 
<<star field>>=
def Rz(c):
    return np.array([[np.cos(c),np.sin(c),0],[-np.sin(c),np.cos(c),0],[0,0,1]])
def Ry(b):
    return np.array([[np.cos(b),0,-np.sin(b)],[0,1,0],[np.sin(b),0,np.cos(b)]])
def Rx(a):
    return np.array([[1,0,0],[0,np.cos(a),np.sin(a)],[0,-np.sin(a),np.cos(a)]])
class StarField:
    def __init__(self,obs,target,field=None,Vmag_lim=18,
                 exclude_radius=Quantity(3,'arcmin'),**kwargs):
        self.obs = obs
        self.target = target
        self.Vmag_lim = Vmag_lim
        self.exclude_radius = exclude_radius
        if field is None:
            radius = Quantity(10,units.arcminute)
            print("@(StarField)> Querying TIC ...")
            self.catalogData = Catalogs.query_region(target.icrs, radius=radius,
                                                catalog="TIC",objType="STAR")
            self.apply_constrains()
        else:
            with open(field) as fp:
                data = yaml.load(fp)
            self.icrs = SkyCoord(ra=Quantity(*data['ra']),
                                 dec=Quantity(*data['dec']),
                                 frame='icrs')
            self.V = data['Vmag']
            self.J = data['Jmag']

            self.update(obs)

    <<star field methods>>
@
<<star field methods>>=
def apply_constrains(self):
    print('@(StarField)> Catalog entry #',len(self.catalogData))
    if self.exclude_radius is not None:
        uu = self.catalogData['ra']*units.deg - self.target.icrs.ra
        vv = self.catalogData['dec']*units.deg - self.target.icrs.dec
        mask = np.hypot(uu,vv) > self.exclude_radius
        print('@(StarField)> Entries accessible #',mask.sum())
    Vmag = np.array(self.catalogData['Vmag'])
    Jmag = np.array(self.catalogData['Jmag'])

    _mask_ = np.logical_and(~np.isnan(Vmag),~np.isnan(Jmag))
    mask = np.logical_and(mask,_mask_)

    Vmag[np.isnan(Vmag)] = self.Vmag_lim+1
    _mask_ = Vmag<=self.Vmag_lim
    mask = np.logical_and(mask,_mask_)

    self.V = Vmag[mask]
    self.J = Jmag[mask]
    data = self.catalogData[mask]
    n = mask.sum()
    print('@(StarField)> Entries with both V and J magnitude #',n)
    if n>0:
        print('@(StarField)> V magnitude range [{0},{1}]'.\
              format(self.V.min(),self.V.max()))
        print('@(StarField)> J magnitude range [{0},{1}]'.\
              format(self.J.min(),self.J.max()))
        self.icrs = SkyCoord(ra=data['ra']*units.deg,
                             dec=data['dec']*units.deg,
                             frame='icrs')
        self.update()
    return n
@
The alt/az coordinates of the star are transformed in a coordinate system
centered and aligned to the target.
<<star field methods>>=
def update(self,*args):
    self.altaz = self.icrs.transform_to( self.obs.frame )
    cra = np.cos(self.altaz.az.to(units.rad))
    sra = np.sin(self.altaz.az.to(units.rad))
    cdec = np.cos(self.altaz.alt.to(units.rad))
    sdec = np.sin(self.altaz.alt.to(units.rad))
    x = cra*cdec
    y = sra*cdec
    z = sdec
    #print(self.target.rotator_angle)
    R = Rz(self.target.rotator_angle) @ \
           Ry(np.pi/2*units.rad-self.target.altaz.alt.to(units.rad)) @ \
           Rz(self.target.altaz.az.to(units.rad))
    v = np.array(np.vstack([x,y,z]))
    self.local = R @ v
@
<<star field methods>>=
def distanceFrom(self,origin=Quantity([[0.0],[0.0]],'arcmin'),
                 star_idx=np.s_[:],u=None):
    dist = np.sqrt(np.sum((self.local[:2,star_idx]-\
                           origin.to(units.rad).value)**2,0))
    if u is not None:
        dist = Quantity(dist,units.rad).to(u)
    return dist
@ %def StarField

\section{TT7 rms residual error}
\label{sec:tt7}

<<TT7 performance estimator>>=
from scipy.special import j0, j1, jn, gamma
from scipy.integrate import quad
def tt7_res_rms(zz,magnitude,r0 = 16e-2,L0 = 25.0,
                zenith_distance = 30*np.pi/180,
                wfs_camera_exposureTime=1/200):
    if magnitude>14:
        return np.Inf
    else:
        def G(_f_,D):
            f = np.array(_f_)
            out = np.ones_like(f)
            idx = f!=0
            red = np.pi*D*f[idx]
            out[idx] = (2*j1(red)/red)**2
            return out
        def integrandSF(f,theta,gam,r0,wl,L0,D,altitude,fr0):
            f0 = 1.0/L0
            cst = np.pi*gamma(11./6.)**2/(2*np.pi**(11./3.))*(24*gamma(6./5.)/5)**(5./6.)
            cst *= wl**2*r0**(-5.0/3.0)*RAD2MAS**2
            sum = 0.0
            for k in range(altitude.size):
                rho = theta*altitude[k]
                red = 2*np.pi*rho*f
                sum += fr0[k]*f**3*(f**2+f0**2)**(-11.0/6.0)*G(f,D)*\
                   ( 1 - j0(red) + np.cos(2*gam)*jn(2,red) )
            return 2*cst*sum
        D = 25.5
        r0_wavelength = 500e-9
        gs_wavelength = 715e-9
        r0 = r0*(gs_wavelength/r0_wavelength)**1.2
        r0 = (r0**(-5./3.)/np.cos(zenith_distance))**(-3./5.)
        seeingArcsec = gs_wavelength/r0*RAD2ARCSEC
        wl = gs_wavelength
        altitude = np.array([25, 275, 425, 1250, 4000, 8000, 13000,])
        fr0 = np.array([0.1257, 0.0874, 0.0666, 0.3498, 0.2273, 0.0681, 0.0751,])
        vs = np.array([5.6540, 5.7964, 5.8942, 6.6370, 13.2925, 34.8250, 29.4187,])
        vd = np.array([0.7798, 8.2564, 12.4752, 32.5007, 72.0987, 93.1994, 100.0507,])*np.pi/180

        cex_var,err = quad(integrandSF,0,np.inf,#limit=200,
                     args=(ARCMIN2RAD*zz,0,r0,wl,L0,D,altitude,fr0))
        cey_var,err = quad(integrandSF,0,np.inf,#limit=200,
                     args=(ARCMIN2RAD*zz,np.pi/2,r0,wl,L0,D,altitude,fr0))

        area = 357
        wfs_camera_photoelectron_gain = 0.8*0.48
        gs_nPhoton = 9e12*10**(-0.4*magnitude)
        nPhLenslet = wfs_camera_exposureTime*wfs_camera_photoelectron_gain*gs_nPhoton
        photon_noise_rms = 1e3*seeingArcsec/np.sqrt(2*np.log(2)*nPhLenslet)

        return np.sqrt(np.sum([cex_var,cey_var,2*photon_noise_rms**2]))
@
\section{Shack--Hartmann guide stars}
\label{sec:sh-gs}

<<SH GSs>>=
def SH_GSs(probes,stars,min_radius=6,nTest=10):
    print('SH GSs...')
    lo = 2*np.pi/3
    mask0 = probes[0].stars_idx
    mask0 = np.logical_or(mask0,probes[1].stars_idx)
    mask0 = np.logical_or(mask0,probes[2].stars_idx)
    stars_xy = stars.local[:2,mask0]
    R = stars.V[mask0]
    stars_r = np.sqrt(np.sum(stars_xy**2,0))
    stars_o = np.arctan2(stars_xy[1,:],stars_xy[0,:])
    q = Quantity(stars_r,'rad').to('arcmin')
    mask = np.logical_and(q>Quantity(min_radius,'arcmin'),q<=Quantity(10,'arcmin'))
    Rmin = []
    az_dist = []
    q = stars_o[mask]
    for c,_q_ in enumerate(q):
        qc = q - _q_
        id2 = [np.argmin(np.abs(qc+lo)),np.argmin(np.abs(qc-lo))]
        az_dist += [np.abs(qc[id2].sum())]
        Rmin += [np.min(R[mask][[c]+id2])]
    L=25.5
    nPx = 101
    nLenslet = 48
    gmt = ceo.GMT_MX(M1_mirror_modes=u"bending modes",M1_N_MODE=27)
    src = ceo.Source(photometric_band="V",
                    rays_box_size=L,rays_box_sampling=nPx,rays_origin=[0,0,25])
    src>>(gmt,)
    zen = np.ones(3)*ceo.constants.ARCMIN2RAD*8
    azi = np.arange(3)*2*np.pi/3
    gs = ceo.Source(photometric_band="R+I",zenith=zen.tolist(),azimuth=azi.tolist(),
                    rays_box_size=L,rays_box_sampling=nPx,rays_origin=[0,0,25])
    def wfs_error_rms_mas(magnitude):
        r0 = 16e-2
        r0_wavelength = 500e-9
        _r0_ = r0*(gs.wavelength/r0_wavelength)**1.2
        seeingArcsec = gs.wavelength/_r0_*ceo.constants.RAD2ARCSEC

        wfs_camera_exposureTime = 30
        wfs_camera_photoelectron_gain = 0.8*0.48
        gs.magnitude = [magnitude]*3
        nPhLenslet = wfs_camera_exposureTime*wfs_camera_photoelectron_gain*gs.nPhoton[0]*(25.5/48)**2
        return 1e3*seeingArcsec/np.sqrt(2*np.log(2)*nPhLenslet)
    az_idx = np.argsort(az_dist)
    median_wfe_rms = []
    for kTest in range(nTest):
        id1 = az_idx[kTest]
        qc = q-q[id1]
        id2 = [np.argmin(np.abs(qc+lo)),np.argmin(np.abs(qc-lo))]
        ids = [id1]+id2
        stars_r[mask][ids],stars_o[mask][ids],R[mask][ids]

        nSample = 100
        wfs = ceo.GeometricShackHartmann(nLenslet,L/nLenslet,3)
        zen = stars_r[mask][ids]#np.ones(3)*ceo.constants.ARCMIN2RAD*gs_radius
        azi = stars_o[mask][ids]#np.arange(3)*2*np.pi/3
        gs = ceo.Source(photometric_band="R+I",zenith=zen.tolist(),azimuth=azi.tolist(),
                        magnitude=R[mask][ids],
                        rays_box_size=L,rays_box_sampling=nPx,rays_origin=[0,0,25])

        gs.reset()
        gmt.reset()
        gmt.propagate(gs)
        wfs.calibrate(gs,0.)
        gs>>(gmt,wfs)

        C = gmt.AGWS_calibrate(wfs,gs,decoupled=True,fluxThreshold=0.5,includeBM=False,
                               filterMirrorRotation=True,
                              calibrationVaultKwargs={'nThreshold':[2]*6+[0],
                                                      'insertZeros':[None]*6 + [[2,7]]})

        nSample = 10
        wfe_rms = np.zeros(nSample)
        for k in range(nSample):
            n = np.random.randn(nLenslet**2*2,3)#
            for l in range(3):
                n[:,l] *= wfs_error_rms_mas(gs.magnitude[l])*ceo.constants.MAS2RAD

            ~gmt
            state = gmt.state
            ~wfs
            +gs
            -wfs
            c = C.dot(wfs.Data + n.reshape(-1,1)).reshape(7,-1)

            state['M1']['Rxyz'] -= c[:,:3]
            state['M1']['Txyz'] -= c[:,3:6]
            state['M2']['Rxyz'] -= c[:,6:9]
            state['M2']['Txyz'] -= c[:,9:12]

            gmt^=state

            +src
            wfe_rms[k] = src.wavefront.rms(-9)

        median_wfe_rms += [np.median(wfe_rms)]
    w = np.argsort(median_wfe_rms)[0]
    id1 = az_idx[w]
    qc = q-q[id1]
    id2 = [np.argmin(np.abs(qc+lo)),np.argmin(np.abs(qc-lo))]
    ids = [id1]+id2
    print(stars_r[mask][ids],stars_o[mask][ids],R[mask][ids])
    for uid in np.where(mask0)[0][mask][ids]:
        probe_id = np.argmin([stars.distanceFrom(Quantity(probe.local,'rad'),
                                                 star_idx=[uid],u='arcmin') for probe in probes])
        probes[probe_id].gs_idx = uid
@
\section{The probes}
\label{sec:probes}

The AGWS is made of 4 identical probes.
The probe envelope dictates t
<<probe.yaml>>=
Probe:
  geometry:
    x: [0,0]
    y: [0,0]
    buffer width: [1.5,'cm']
  guider:
    fov: [30,'arcsec']
  tt7:
    fov: [5,'arcsec']
@
<<probe>>=
class Probe:
    def __init__(self,az,exclude_rad=Quantity(2,'arcmin')):
        self.rad = Quantity(1360/60,'arcmin')
        self.az  = az
        self.range_rad = self.rad - exclude_rad
        self.local = np.array([[self.rad.to('rad').value*np.cos(self.az).value],
                               [self.rad.to('rad').value*np.sin(self.az).value]])
        self.gs_idx = None
    def reachForTheStars(self,stars):
        dist_to_probe = stars.distanceFrom(Quantity(self.local,'rad'))
        self.stars_idx = dist_to_probe<=self.range_rad.to('rad').value
@
\section{Display}
\label{sec:display}

<<main.py>>=
from bokeh.io import curdoc
from bokeh.plotting import figure, show, output_file
from bokeh.models import ColorBar, LinearColorMapper, BasicTicker, \
    ColumnDataSource, PrintfTickFormatter, HoverTool
from bokeh.palettes import Plasma11, Spectral4
from bokeh.layouts import widgetbox, row, column, layout
from bokeh.models.widgets import Button, Slider, Select, Panel, \
    Tabs, CheckboxGroup, TextInput, Div, Toggle
import numpy as np
import yaml
from astropy.units import Quantity
from atp import Observatory, Target, StarField, Probe, tt7_res_rms, SH_GSs

CFG_FILE = __file__.replace('main.py','atp.yaml')
<<reading the atp config file>>
agws = {'obs':None,'target':None,'stars':None,'TT7':None,
        'probes':[Probe(Quantity(k*90,'degree')) for k in range(4)],
        'source':ColumnDataSource(data=dict(x=[],y=[],
                                            Vmag=[],c=[],Jmag=[]))}
r2a = 180*60/np.pi
probes_sources = {'mirror':[],'stage':[]}
for k in range(4):
    probes_sources['mirror'] += [ColumnDataSource(data=dict(tx=[],ty=[],lc=[]))]
    probes_sources['stage']  += [ColumnDataSource(data=dict(px=[],py=[]))]

doc = curdoc()

<<widgets>>

p = figure(title='AGWS',x_range=[-25,25],y_range=[-25,25],
           tools="pan,wheel_zoom,box_zoom,reset")
probes = agws['probes']
for k in range(4):
    p.line(x='px',y='py',source=probes_sources['stage'][k],
           line_width=5,color='navy')
    p.circle(x='tx',y='ty',line_color='lc',source=probes_sources['mirror'][k],
             size=10,fill_color=None,line_width=3)
    p.wedge(r2a*probes[k].local[0,0],r2a*probes[k].local[1,0],radius=21,
            start_angle=(k*90+180-26.35)*np.pi/180,
            end_angle=(k*90+180+26.35)*np.pi/180,
            color='navy',alpha=0.05)
    p.circle(r2a*probes[k].local[0,0],r2a*probes[k].local[1,0],
             size=15,color='navy')
p.circle(x='x',y='y',color='c',size=5,source=agws['source'],
         alpha=0.75,name='stars')
p.circle(0,0,radius=3,fill_color=None,line_color='red',line_dash='dashed')
p.circle(0,0,radius=10,fill_color=None,line_color='red',line_dash='dashed')
p.xaxis.axis_label = "[arcmin]"
p.yaxis.axis_label = "[arcmin]"
p.add_tools(HoverTool(names=['stars'],tooltips=[("V", "@Vmag"),("J", "@Jmag")]))

doc.add_root(row(widgetbox([datetime,
                            target_name,tel_alt,tel_az,
                            query,V_lim,find_tt7,
                            time_res,startstop,rotator]),p))
#update()
@

\subsection{Widgets}
\label{sec:widgets}

\begin{itemize}
\item start and stop the time:
<<widgets>>=
startstop = Toggle(label="Start/Stop Time", button_type="default" ,active=False)
def update():
    obs = agws['obs']
    target = agws['target']
    stars = agws['stars']
    source = agws['source']
    probes = [agws['TT7']]+agws['probes']
    obs.update()
    target.update(rotator=rotator.active)
    stars.update()
    x = r2a*stars.local[0,:]
    y = r2a*stars.local[1,:]
    source.data.update(dict(x=x,y=y))
    p.title.text = "AGWS - "+str(obs.current_time)+\
                   ' - Alt: '+str(target.altaz.alt)+\
                   ',Az: '+str(target.altaz.az)
    for probe,mirror,stage in zip(probes,probes_sources['mirror'],probes_sources['stage']):
        """
        p.line([r2a*probe.local[0,0],r2a*stars.local[0,probe.gs_idx]],
               [r2a*probe.local[1,0],r2a*stars.local[1,probe.gs_idx]],
               line_width=5,color='navy')
        p.circle(r2a*stars.local[0,probe.gs_idx],r2a*stars.local[1,probe.gs_idx],
                 size=10,fill_color=None,line_color='DarkSeaGreen',line_width=3)
        """
        src = ColumnDataSource(data=dict(tx=[r2a*stars.local[0,probe.gs_idx]],
                                         ty=[r2a*stars.local[1,probe.gs_idx]],
                                         lc=['DarkSeaGreen']))
        data = dict(tx=[r2a*stars.local[0,probe.gs_idx]],
                    ty=[r2a*stars.local[1,probe.gs_idx]])
        mirror.data.update(data)
        data = dict(px=[r2a*probe.local[0,0],r2a*stars.local[0,probe.gs_idx]],
                    py=[r2a*probe.local[1,0],r2a*stars.local[1,probe.gs_idx]])
        stage.data.update(data)

        

widget_data = {'startstop':None}
callback_id = None
def cb_startstop(attrname, old, new):
    global callback_id
    print(attrname, old, new)
    if new:
        print('Add callback')
        callback_id = doc.add_periodic_callback(update,1000)
    else:
        print('Remove callback')
        doc.remove_periodic_callback(callback_id)
startstop.on_change('active',cb_startstop)
@ 
\item the date and time (UTC)
<<widgets>>=
datetime = TextInput(value="2018-01-01T04:00:00.000", title="Date and time (UTC)")
@
\item the time resolution
<<widgets>>=
time_res = TextInput(value="60", title="Time resolution [s]")
@
\item the target name
<<widgets>>=
target_name = TextInput(value="None", title="Target name")
@
\item the telescope pointing direction (alt/az)
<<widgets>>=
tel_alt = TextInput(value="45", title="Telescope altitude [degree]")
tel_az = TextInput(value="0", title="Telescope azimuth [degree]")
@
\item queries star
<<widgets>>=
query = Button(label="Query field", button_type="default")
def cb_query():
    agws['obs'] = Observatory(cfg['Observatory'],
                              {'time':datetime.value,
                               'time resolution':[float(time_res.value),'second']})
    agws['target'] = Target(agws['obs'],{'pointing target':target_name.value,
                                 'pointing ra/dec':None,
                                 'pointing alt/az':{'alt':[float(tel_alt.value),'degree'],
                                                    'az':[float(tel_az.value),'degree']}})
    agws['probes'] = [Probe(Quantity(k*90,'degree')) for k in range(4)]
    #probes_sources['mirror'] = []
    #probes_sources['stage'] = []
    #for k in range(4):
    #    probes_sources['mirror'] += [ColumnDataSource(data=dict(tx=[],ty=[],lc=[]))]
    #    probes_sources['stage']  += [ColumnDataSource(data=dict(px=[],py=[]))]
    tel_alt.value = "%.2f"%agws['target'].altaz.alt.value
    tel_az.value = "%.2f"%agws['target'].altaz.az.value
    agws['stars']  = StarField(agws['obs'],agws['target'])
    stars = agws['stars']
    for k in range(4):
        agws['probes'][k].reachForTheStars(stars)
    Vmag = stars.V#[idx]
    Jmag = stars.J#[idx]
    q = np.rint((Vmag - Vmag.min())/(Vmag.max()-Vmag.min())*10)
    c = [Plasma11[int(x)] for x in q]
    src = ColumnDataSource(data=dict(x=r2a*stars.local[0,:],
                                     y=r2a*stars.local[1,:],
                                     Vmag=Vmag,c=c,Jmag=Jmag))
    agws['source'].data.update(src.data)
    p.title.text = "AGWS - "+str(agws['obs'].current_time)+\
                   ' - Alt: '+str(agws['target'].altaz.alt)+\
                   ',Az: '+str(agws['target'].altaz.az)
    V_lim.start = np.floor(stars.V.min())
    V_lim.end   = np.ceil(stars.V.max())
    V_lim.value = stars.Vmag_lim

query.on_click(cb_query)
@
\item find the guide stars
<<widgets>>=
find_tt7 = Button(label="Find GSs", button_type="default")
def cb_find_tt7():
    stars = agws['stars']
    probes = agws['probes']
    tt_res_rms = [tt7_res_rms(zz,magnitude) for zz,magnitude in zip(stars.distanceFrom(u='arcmin').value,stars.V)]
    tt7_gs_idx = np.argmin(tt_res_rms)
    tt7_dist = []
    for k in range(4):
        tt7_dist += [stars.distanceFrom(Quantity(probes[k].local,'rad'),star_idx=[tt7_gs_idx],u='arcmin')]
    tt7_idx = np.argmin(tt7_dist)
    agws['TT7'] = probes[tt7_idx]
    TT7 = agws['TT7']
    TT7.gs_idx = tt7_gs_idx
    probes.pop(tt7_idx)
    """
    p.line([r2a*TT7.local[0,0],r2a*stars.local[0,TT7.gs_idx]],
           [r2a*TT7.local[1,0],r2a*stars.local[1,TT7.gs_idx]],
           line_width=5,color='navy')
    p.circle(r2a*stars.local[0,TT7.gs_idx],r2a*stars.local[1,TT7.gs_idx],
             size=10,fill_color=None,line_color='FireBrick',line_width=3)
    """
    SH_GSs(probes,stars)

    probes = [TT7]+probes
    for probe,mirror,stage,c in zip(probes,
                                    probes_sources['mirror'],
                                    probes_sources['stage'],
                                    ['FireBrick']+['DarkSeaGreen']*3):
        """
        p.line([r2a*probe.local[0,0],r2a*stars.local[0,probe.gs_idx]],
               [r2a*probe.local[1,0],r2a*stars.local[1,probe.gs_idx]],
               line_width=5,color='navy')
        p.circle(r2a*stars.local[0,probe.gs_idx],r2a*stars.local[1,probe.gs_idx],
                 size=10,fill_color=None,line_color='DarkSeaGreen',line_width=3)
        """
        src = ColumnDataSource(data=dict(tx=[r2a*stars.local[0,probe.gs_idx]],
                                         ty=[r2a*stars.local[1,probe.gs_idx]],
                                         lc=[c]))
        mirror.data.update(src.data)
        src = ColumnDataSource(data=dict(px=[r2a*probe.local[0,0],r2a*stars.local[0,probe.gs_idx]],
                                         py=[r2a*probe.local[1,0],r2a*stars.local[1,probe.gs_idx]]))
        stage.data.update(src.data)

find_tt7.on_click(cb_find_tt7)
@
\item the GIR
<<widgets>>=
rotator = Toggle(label="Rotator On/Off", button_type="default" ,active=False)
@
\item R magnitude limit
<<widgets>>=
V_lim = Slider(start=0,end=18,value=18,step=1,title='V magnitude limit')
def  cb_V_lim(attrname, old, new):
    stars = agws['stars']
    stars.Vmag_lim = new
    stars.apply_constrains()
    for k in range(4):
        agws['probes'][k].reachForTheStars(stars)
    Vmag = stars.V#[idx]
    Jmag = stars.J#[idx]
    q = np.rint((Vmag - Vmag.min())/(Vmag.max()-Vmag.min())*10)
    c = [Plasma11[int(x)] for x in q]
    src = ColumnDataSource(data=dict(x=r2a*stars.local[0,:],
                                     y=r2a*stars.local[1,:],
                                     Vmag=Vmag,c=c,Jmag=Jmag))
    agws['source'].data.update(src.data)
V_lim.on_change('value',cb_V_lim)
@
\end{itemize}
    


