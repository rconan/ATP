
\section{Introduction}
\label{sec:introduction}

\section{Installation}
\label{sec:installation}

\section{Implementation}
\label{sec:implementation}

\section{Observation}
\label{sec:observation}

<<Observation config>>=
Observation:
   time: '2018-01-01T00:00:00'
   time resolution: [60,'second']
@ 
\section{The Observatory}
\label{sec:gmt}

<<Observatory config>>=
Observatory:
   latitude: [-29.049,'degree']
   longitude:  [-70.682,'degree']
   height: [2514,'meter']
   pointing target: null
   pointing ra/dec: null
   pointing alt/az:
      alt: [45,'degree']
      az: [0,'degree']
   pointing accuracy: null
@
<<observatory>>=
class Observatory:
    def __init__(self,cfg):
        self.location = EarthLocation(lat=Quantity(*cfg['Observatory']['latitude']),
                                      lon=Quantity(*cfg['Observatory']['longitude']),
                                      height=Quantity(*cfg['Observatory']['height']))
        self.time = Time(cfg['Observation']['time'])
        print("@(Observatory)> Time:", Time(self.time, format='isot'))
        if self.time is None:
            self.time = Time(datetime.now())
        self.time_resolution = Quantity(*cfg['Observation']['time resolution'])
        
    def update(self):
        self.time += self.time_resolution

    @property
    def frame(self):
        return AltAz(obstime=self.time,
                     location=self.location)
@ %def Observatory

\section{Target}
\label{sec:target}

The target defines the direction the telescope is pointing at.
The target is given by either the name of an astronomical object or sky coordinates in ra/dec or alt/az.
<<target>>=
class Target:
    def __init__(self,cfg,obs):
        if cfg['Observatory']['pointing target'] is not None:
            self.icrs  = SkyCoord.from_name(cfg['Observatory']['pointing target'],
                                            frame='icrs')
            self.altaz = self.icrs.transform_to( obs.frame() )
        if cfg['Observatory']['pointing ra/dec'] is not None:
            self.icrs  = SkyCoord(ra=Quantity(*cfg['Observatory']['pointing ra/dec']['ra']),
                                  dec=Quantity(*cfg['Obs change mode keyervatory']['pointing ra/dec']['dec']),
                                  frame='icrs')
            self.altaz = self.icrs.transform_to( obs.frame )
        if cfg['Observatory']['pointing alt/az'] is not None:
            self.altaz = SkyCoord(alt=Quantity(*cfg['Observatory']['pointing alt/az']['alt']),
                                  az=Quantity(*cfg['Observatory']['pointing alt/az']['az']),
                                  frame = obs.frame)
            self.icrs  = self.altaz.transform_to( ICRS() )
        print("@(Target)>")
        print(self.icrs)
        print(self.altaz)

    def update(self,obs):
        self.altaz = self.icrs.transform_to( obs.frame )
@ %def Target

\section{AGWS Star Field}
\label{sec:star-field}

An AGWS star field is read from the TESS Input Catalogue (TIC\footnote{\url{https://tess.mit.edu/data/tess-input-catalogue/}}).
A 10 arcmin radius circular region is queried from the catalogue centered on either a given target or a given sky alt/az coordinate.
An observation date and time must also be specified, the default is the current date and time.
The data is further reduced to objects that have both a magnitude in R and J bands.
<<module imports>>=
import numpy as np
from astroquery.mast import Catalogs
import astropy.units as units
from astropy.units import Quantity
from astropy.time import Time
from astropy.coordinates import SkyCoord, EarthLocation, ICRS, AltAz
@ 
<<star field>>=
def Rz(c):
    return np.array([[np.cos(c),np.sin(c),0],[-np.sin(c),np.cos(c),0],[0,0,1]])
def Ry(b):
    return np.array([[np.cos(b),0,-np.sin(b)],[0,1,0],[np.sin(b),0,np.cos(b)]])
class StarField:
    def __init__(self,obs,target):
        radius = Quantity(10,units.arcminute)
        print("@(StarField)> Querying TIC ...")
        self.target = target
        catalogData = Catalogs.query_region(target.icrs, radius=radius,
                                            catalog="TIC",objType="STAR")
        print('@(StarField)> Catalog entry #',len(catalogData))
        Rmag = np.array(catalogData['rmag'])
        Jmag = np.array(catalogData['Jmag'])
        mask = np.logical_and(~np.isnan(Rmag),~np.isnan(Jmag))
        n = mask.sum()
        print('@(StarField)> Entries with both R and J magnitude #',n)
        self.R = Rmag[mask]
        self.J = Jmag[mask]
        if n>0:
            print('@(StarField)> R magnitude range [{0},{1}]'.format(self.R.min(),self.R.max()))
            print('@(StarField)> J magnitude range [{0},{1}]'.format(self.J.min(),self.J.max()))
            data = catalogData[mask]
            self.icrs = SkyCoord(ra=data['ra']*units.deg,
                                 dec=data['dec']*units.deg,
                                 frame='icrs')
            self.update(obs)

    def update(self,obs):
        self.altaz = self.icrs.transform_to( obs.frame )
        cra = np.cos(self.altaz.az.to(units.rad))
        sra = np.sin(self.altaz.az.to(units.rad))
        cdec = np.cos(self.altaz.alt.to(units.rad))
        sdec = np.sin(self.altaz.alt.to(units.rad))
        x = cra*cdec
        y = sra*cdec
        z = sdec
        R = Ry(np.pi/2*units.rad-self.target.altaz.alt.to(units.rad)) @ \
            Rz(self.target.altaz.az.to(units.rad))
        v = np.array(np.vstack([x,y,z]))
        self.local = R @ v              
@ %def StarField
<<Star field config>>=
STAR CATALOG:
   ra/dec error rms: null
@

\section{Display}
\label{sec:display}

<<main.py>>=
from bokeh.io import curdoc
from bokeh.plotting import figure, show, output_file
from bokeh.models import ColorBar, LinearColorMapper, BasicTicker, \
    ColumnDataSource, PrintfTickFormatter, HoverTool
from bokeh.palettes import Plasma11
from bokeh.layouts import widgetbox, row, column, layout
from bokeh.models.widgets import Button, Slider, Select, Panel, \
    Tabs, CheckboxGroup, TextInput, Div
import numpy as np
import yaml
import atp

CFG_FILE = 'ATP/atp.yaml'
<<reading the atp config file>>
print(cfg)
obs = atp.Observatory(cfg)
target = atp.Target(cfg,obs)
stars  = atp.StarField(obs,target)
r2a = 180*60/np.pi

mlim = np.inf
idx = stars.R<=mlim
m = stars.R[idx]
q = np.rint((m - m.min())/(m.max()-m.min())*10)
c = [Plasma11[int(x)] for x in q]
source = ColumnDataSource(data=dict(x=r2a*stars.local[0,idx],
                                    y=r2a*stars.local[1,idx],
                                    m=m,c=c))

def update():
    obs.update()
    target.update(obs)
    stars.update(obs)
    x = r2a*stars.local[0,idx]
    y = r2a*stars.local[1,idx]
    #print(len(x),len(y),len(m),len(c))
    source.data['x'] = x
    source.data['y'] = y
    #new_data = {'x':x,'y':y,'m':m,'c':c}
    #source.stream(new_data)
    p.title.text = "AGWS Target Practice - "+str(obs.time)+\
                   ' - Alt: '+str(target.altaz.alt)+',Az: '+str(target.altaz.az)

hover = HoverTool(tooltips=[("R", "@m")])
p = figure(title="AGWS Target Practice - "+str(obs.time)+\
           ' - Alt: '+str(target.altaz.alt)+',Az: '+str(target.altaz.az),
           x_range=[-20,20],y_range=[-20,20],tools=[hover])
p.circle(x='x',y='y',color='c',size=7,source=source)
doc = curdoc()
doc.add_root(p)
doc.add_periodic_callback(update,1000)
@
\section{Files}
\label{sec:files}

The main python module is
<<atp.py>>=
<<module imports>>
from datetime import datetime
<<observatory>>
<<target>>
<<star field>>

if __name__ == "__main__":
    CFG_FILE = 'atp.yaml'
    <<reading the atp config file>>
    obs = Observatory(cfg)
    target = Target(cfg,obs)
    stars  = StarField(obs,target)
@

\subsection{Configuration}
\label{sec:config}

<<atp.yaml>>=
<<Observation config>>
<<Observatory config>>
<<Star field config>>
@
The configuration file is read with:
<<module imports>>=
import yaml
@
<<reading the atp config file>>=
with open(CFG_FILE) as fp:
    cfg = yaml.load(fp)
@ %def cfg
    


